{"version":3,"sources":["../node_modules/@graphiql/react/dist/foldgutter.es.js"],"names":["__webpack_require__","r","__webpack_exports__","d","foldgutter$1","_mergeNamespaces2","_Users_mdizon_Code_broth_graphene_graphiql_explorer_graphene_graphiql_explorer_src_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__","_codemirror_es_js__WEBPACK_IMPORTED_MODULE_1__","__defProp","Object","defineProperty","__name","target","value","configurable","_mergeNamespaces","n","m","forEach","e","Array","isArray","keys","k","getOwnPropertyDescriptor","get","enumerable","freeze","foldgutter$2","exports","CodeMirror","doFold","cm","pos","options","force","call","finder","getOption","Pos","minSize","getRange","allowFolded","range2","to","line","from","marks","findMarksAt","i","length","__isFold","cleared","clear","range","firstLine","myWidget","makeWidget","on","myRange","e_preventDefault","markText","replacedWith","clearOnEnter","signal","widget","text","document","createTextNode","createElement","appendChild","className","cloneNode","newFoldFunction","rangeFinder","defineExtension","this","commands","toggleFold","foldCode","getCursor","fold","unfold","scanUp","foldAll","operation","lastLine","unfoldAll","registerHelper","funcs","prototype","slice","arguments","start","found","helpers","getHelpers","cur","defaultOptions","auto","minFoldSize","name","editorOptions","foldOptions","defineOption","mod","val","old","Init","clearGutter","state","foldGutter","gutter","off","onGutterClick","onChange","onViewportChange","onFold","State","parseOptions","updateInViewport","opts","indicatorOpen","indicatorFolded","isFolded","findMarks","fromPos","find","marker","spec","elt","updateFoldInfo","foldOption","func","clsFolded","classTest","clsOpen","eachLine","mark","gutterMarkers","test","setGutterMarker","cls","RegExp","vp","getViewport","folded","clearTimeout","changeUpdate","setTimeout","foldOnChangeTimeSpan","updateViewportTimeSpan","foldgutter","__proto__","Symbol","toStringTag"],"mappings":"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","file":"static/js/7.357cdd8b.chunk.js","sourcesContent":["import _defineProperty from \"/Users/mdizon/Code/broth/graphene-graphiql-explorer/graphene_graphiql_explorer/src/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _mergeNamespaces2;\n\nvar __defProp = Object.defineProperty;\n\nvar __name = function __name(target, value) {\n  return __defProp(target, \"name\", {\n    value: value,\n    configurable: true\n  });\n};\n\nimport { a as codemirror } from \"./codemirror.es.js\";\n\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function (e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function get() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n\n__name(_mergeNamespaces, \"_mergeNamespaces\");\n\nvar foldgutter$2 = {\n  exports: {}\n};\nvar foldcode = {\n  exports: {}\n};\n\n(function (module, exports) {\n  (function (mod) {\n    mod(codemirror.exports);\n  })(function (CodeMirror) {\n    function doFold(cm, pos, options, force) {\n      if (options && options.call) {\n        var finder = options;\n        options = null;\n      } else {\n        var finder = getOption(cm, options, \"rangeFinder\");\n      }\n\n      if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n      var minSize = getOption(cm, options, \"minFoldSize\");\n\n      function getRange(allowFolded) {\n        var range2 = finder(cm, pos);\n        if (!range2 || range2.to.line - range2.from.line < minSize) return null;\n        if (force === \"fold\") return range2;\n        var marks = cm.findMarksAt(range2.from);\n\n        for (var i = 0; i < marks.length; ++i) {\n          if (marks[i].__isFold) {\n            if (!allowFolded) return null;\n            range2.cleared = true;\n            marks[i].clear();\n          }\n        }\n\n        return range2;\n      }\n\n      __name(getRange, \"getRange\");\n\n      var range = getRange(true);\n      if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n        pos = CodeMirror.Pos(pos.line - 1, 0);\n        range = getRange(false);\n      }\n      if (!range || range.cleared || force === \"unfold\") return;\n      var myWidget = makeWidget(cm, options, range);\n      CodeMirror.on(myWidget, \"mousedown\", function (e) {\n        myRange.clear();\n        CodeMirror.e_preventDefault(e);\n      });\n      var myRange = cm.markText(range.from, range.to, {\n        replacedWith: myWidget,\n        clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n        __isFold: true\n      });\n      myRange.on(\"clear\", function (from, to) {\n        CodeMirror.signal(cm, \"unfold\", cm, from, to);\n      });\n      CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n    }\n\n    __name(doFold, \"doFold\");\n\n    function makeWidget(cm, options, range) {\n      var widget = getOption(cm, options, \"widget\");\n\n      if (typeof widget == \"function\") {\n        widget = widget(range.from, range.to);\n      }\n\n      if (typeof widget == \"string\") {\n        var text = document.createTextNode(widget);\n        widget = document.createElement(\"span\");\n        widget.appendChild(text);\n        widget.className = \"CodeMirror-foldmarker\";\n      } else if (widget) {\n        widget = widget.cloneNode(true);\n      }\n\n      return widget;\n    }\n\n    __name(makeWidget, \"makeWidget\");\n\n    CodeMirror.newFoldFunction = function (rangeFinder, widget) {\n      return function (cm, pos) {\n        doFold(cm, pos, {\n          rangeFinder: rangeFinder,\n          widget: widget\n        });\n      };\n    };\n\n    CodeMirror.defineExtension(\"foldCode\", function (pos, options, force) {\n      doFold(this, pos, options, force);\n    });\n    CodeMirror.defineExtension(\"isFolded\", function (pos) {\n      var marks = this.findMarksAt(pos);\n\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold) return true;\n      }\n    });\n\n    CodeMirror.commands.toggleFold = function (cm) {\n      cm.foldCode(cm.getCursor());\n    };\n\n    CodeMirror.commands.fold = function (cm) {\n      cm.foldCode(cm.getCursor(), null, \"fold\");\n    };\n\n    CodeMirror.commands.unfold = function (cm) {\n      cm.foldCode(cm.getCursor(), {\n        scanUp: false\n      }, \"unfold\");\n    };\n\n    CodeMirror.commands.foldAll = function (cm) {\n      cm.operation(function () {\n        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) {\n          cm.foldCode(CodeMirror.Pos(i, 0), {\n            scanUp: false\n          }, \"fold\");\n        }\n      });\n    };\n\n    CodeMirror.commands.unfoldAll = function (cm) {\n      cm.operation(function () {\n        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) {\n          cm.foldCode(CodeMirror.Pos(i, 0), {\n            scanUp: false\n          }, \"unfold\");\n        }\n      });\n    };\n\n    CodeMirror.registerHelper(\"fold\", \"combine\", function () {\n      var funcs = Array.prototype.slice.call(arguments, 0);\n      return function (cm, start) {\n        for (var i = 0; i < funcs.length; ++i) {\n          var found = funcs[i](cm, start);\n          if (found) return found;\n        }\n      };\n    });\n    CodeMirror.registerHelper(\"fold\", \"auto\", function (cm, start) {\n      var helpers = cm.getHelpers(start, \"fold\");\n\n      for (var i = 0; i < helpers.length; i++) {\n        var cur = helpers[i](cm, start);\n        if (cur) return cur;\n      }\n    });\n    var defaultOptions = {\n      rangeFinder: CodeMirror.fold.auto,\n      widget: \"\\u2194\",\n      minFoldSize: 0,\n      scanUp: false,\n      clearOnEnter: true\n    };\n    CodeMirror.defineOption(\"foldOptions\", null);\n\n    function getOption(cm, options, name) {\n      if (options && options[name] !== void 0) return options[name];\n      var editorOptions = cm.options.foldOptions;\n      if (editorOptions && editorOptions[name] !== void 0) return editorOptions[name];\n      return defaultOptions[name];\n    }\n\n    __name(getOption, \"getOption\");\n\n    CodeMirror.defineExtension(\"foldOption\", function (options, name) {\n      return getOption(this, options, name);\n    });\n  });\n})();\n\n(function (module, exports) {\n  (function (mod) {\n    mod(codemirror.exports, foldcode.exports);\n  })(function (CodeMirror) {\n    CodeMirror.defineOption(\"foldGutter\", false, function (cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        cm.clearGutter(cm.state.foldGutter.options.gutter);\n        cm.state.foldGutter = null;\n        cm.off(\"gutterClick\", onGutterClick);\n        cm.off(\"changes\", onChange);\n        cm.off(\"viewportChange\", onViewportChange);\n        cm.off(\"fold\", onFold);\n        cm.off(\"unfold\", onFold);\n        cm.off(\"swapDoc\", onChange);\n      }\n\n      if (val) {\n        cm.state.foldGutter = new State(parseOptions(val));\n        updateInViewport(cm);\n        cm.on(\"gutterClick\", onGutterClick);\n        cm.on(\"changes\", onChange);\n        cm.on(\"viewportChange\", onViewportChange);\n        cm.on(\"fold\", onFold);\n        cm.on(\"unfold\", onFold);\n        cm.on(\"swapDoc\", onChange);\n      }\n    });\n    var Pos = CodeMirror.Pos;\n\n    function State(options) {\n      this.options = options;\n      this.from = this.to = 0;\n    }\n\n    __name(State, \"State\");\n\n    function parseOptions(opts) {\n      if (opts === true) opts = {};\n      if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n      if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n      if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n      return opts;\n    }\n\n    __name(parseOptions, \"parseOptions\");\n\n    function isFolded(cm, line) {\n      var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold) {\n          var fromPos = marks[i].find(-1);\n          if (fromPos && fromPos.line === line) return marks[i];\n        }\n      }\n    }\n\n    __name(isFolded, \"isFolded\");\n\n    function marker(spec) {\n      if (typeof spec == \"string\") {\n        var elt = document.createElement(\"div\");\n        elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n        return elt;\n      } else {\n        return spec.cloneNode(true);\n      }\n    }\n\n    __name(marker, \"marker\");\n\n    function updateFoldInfo(cm, from, to) {\n      var opts = cm.state.foldGutter.options,\n          cur = from - 1;\n      var minSize = cm.foldOption(opts, \"minFoldSize\");\n      var func = cm.foldOption(opts, \"rangeFinder\");\n      var clsFolded = typeof opts.indicatorFolded == \"string\" && classTest(opts.indicatorFolded);\n      var clsOpen = typeof opts.indicatorOpen == \"string\" && classTest(opts.indicatorOpen);\n      cm.eachLine(from, to, function (line) {\n        ++cur;\n        var mark = null;\n        var old = line.gutterMarkers;\n        if (old) old = old[opts.gutter];\n\n        if (isFolded(cm, cur)) {\n          if (clsFolded && old && clsFolded.test(old.className)) return;\n          mark = marker(opts.indicatorFolded);\n        } else {\n          var pos = Pos(cur, 0);\n          var range = func && func(cm, pos);\n\n          if (range && range.to.line - range.from.line >= minSize) {\n            if (clsOpen && old && clsOpen.test(old.className)) return;\n            mark = marker(opts.indicatorOpen);\n          }\n        }\n\n        if (!mark && !old) return;\n        cm.setGutterMarker(line, opts.gutter, mark);\n      });\n    }\n\n    __name(updateFoldInfo, \"updateFoldInfo\");\n\n    function classTest(cls) {\n      return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\");\n    }\n\n    __name(classTest, \"classTest\");\n\n    function updateInViewport(cm) {\n      var vp = cm.getViewport(),\n          state = cm.state.foldGutter;\n      if (!state) return;\n      cm.operation(function () {\n        updateFoldInfo(cm, vp.from, vp.to);\n      });\n      state.from = vp.from;\n      state.to = vp.to;\n    }\n\n    __name(updateInViewport, \"updateInViewport\");\n\n    function onGutterClick(cm, line, gutter) {\n      var state = cm.state.foldGutter;\n      if (!state) return;\n      var opts = state.options;\n      if (gutter != opts.gutter) return;\n      var folded = isFolded(cm, line);\n      if (folded) folded.clear();else cm.foldCode(Pos(line, 0), opts);\n    }\n\n    __name(onGutterClick, \"onGutterClick\");\n\n    function onChange(cm) {\n      var state = cm.state.foldGutter;\n      if (!state) return;\n      var opts = state.options;\n      state.from = state.to = 0;\n      clearTimeout(state.changeUpdate);\n      state.changeUpdate = setTimeout(function () {\n        updateInViewport(cm);\n      }, opts.foldOnChangeTimeSpan || 600);\n    }\n\n    __name(onChange, \"onChange\");\n\n    function onViewportChange(cm) {\n      var state = cm.state.foldGutter;\n      if (!state) return;\n      var opts = state.options;\n      clearTimeout(state.changeUpdate);\n      state.changeUpdate = setTimeout(function () {\n        var vp = cm.getViewport();\n\n        if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n          updateInViewport(cm);\n        } else {\n          cm.operation(function () {\n            if (vp.from < state.from) {\n              updateFoldInfo(cm, vp.from, state.from);\n              state.from = vp.from;\n            }\n\n            if (vp.to > state.to) {\n              updateFoldInfo(cm, state.to, vp.to);\n              state.to = vp.to;\n            }\n          });\n        }\n      }, opts.updateViewportTimeSpan || 400);\n    }\n\n    __name(onViewportChange, \"onViewportChange\");\n\n    function onFold(cm, from) {\n      var state = cm.state.foldGutter;\n      if (!state) return;\n      var line = from.line;\n      if (line >= state.from && line < state.to) updateFoldInfo(cm, line, line + 1);\n    }\n\n    __name(onFold, \"onFold\");\n  });\n})();\n\nvar foldgutter = foldgutter$2.exports;\nvar foldgutter$1 =\n/* @__PURE__ */\nObject.freeze(\n/* @__PURE__ */\n_mergeNamespaces((_mergeNamespaces2 = {\n  __proto__: null\n}, _defineProperty(_mergeNamespaces2, Symbol.toStringTag, \"Module\"), _defineProperty(_mergeNamespaces2, \"default\", foldgutter), _mergeNamespaces2), [foldgutter$2.exports]));\nexport { foldgutter$1 as f };"],"sourceRoot":""}