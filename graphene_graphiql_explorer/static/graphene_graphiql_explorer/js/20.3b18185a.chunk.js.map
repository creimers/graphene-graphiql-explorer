{"version":3,"sources":["../node_modules/@graphiql/react/dist/mode.es3.js","../node_modules/@graphiql/react/dist/onlineParser.es.js"],"names":["__webpack_require__","r","__webpack_exports__","_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__","_index_es_js__WEBPACK_IMPORTED_MODULE_1__","_onlineParser_es_js__WEBPACK_IMPORTED_MODULE_2__","__defProp","Object","defineProperty","__name","target","value","configurable","indent","state","textAfter","_a","_b","levels","length","this","electricInput","test","indentLevel","config","indentUnit","defineMode","parser","eatWhitespace","stream","eatSpace","lexRules","LexRules","parseRules","ParseRules","editorConfig","tabSize","startState","token","fold","closeBrackets","pairs","explode","Punctuation","Number","String","Keyword","Document","Variable","namedKey","Value","kind","NumberValue","StringValue","BooleanValue","NullValue","ListValue","ObjectValue","ObjectField","style","match","update","name","slice","d","onlineParser","_index_es_js__WEBPACK_IMPORTED_MODULE_0__","graphql__WEBPACK_IMPORTED_MODULE_1__","options","arguments","undefined","eatWhile","initialState","level","step","type","rule","needsSeparator","prevState","pushRule","DOCUMENT","getToken","inBlockstring","skipToEnd","popRule","needsAdvance","advanceRule","sol","Math","floor","indentation","lex","SpecialParseRules","backupState","assign","concat","expected","separator","ofRule","call","unsuccessful","to","from","keys","i","Invalid","Comment","rules","ruleKind","TypeError","successful","isList","Array","isArray","kinds"],"mappings":"2FAAAA,EAAAC,EAAAC,GAAA,IAAAC,EAAAH,EAAA,KAAAI,EAAAJ,EAAA,IAAAK,EAAAL,EAAA,KAAAM,GAAAN,EAAA,GAAAA,EAAA,IAAAO,OAAAC,gBAEAC,EAAA,SAAAC,EAAAC,GACA,OAAAL,EAAAI,EAAA,QACAC,QACAC,cAAA,KAmCA,SAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAC,EAEAC,EAAAJ,EAAAI,OAEA,QADAA,GAAA,IAAAA,EAAAC,OAAAD,IAAAC,OAAA,aAAAH,EAAAI,KAAAC,qBAAA,IAAAL,OAAA,EAAAA,EAAAM,KAAAP,IAAA,KAAAD,EAAAS,cACA,aAAAN,EAAAG,KAAAI,cAAA,IAAAP,OAAA,EAAAA,EAAAQ,aAAA,GA9BAtB,EAAA,EAAUuB,WAAA,6BAAAF,GACV,IAAAG,EAAepB,OAAAF,EAAA,EAAAE,CAAY,CAC3BqB,cAAA,SAAAC,GACA,OAAAA,EAAAC,YAEAC,SAAAC,EACAC,WAAAC,EACAC,aAAA,CACAC,QAAAZ,EAAAY,WAGA,OACAZ,SACAa,WAAAV,EAAAU,WACAC,MAAAX,EAAAW,MACAzB,SACAQ,cAAA,YACAkB,KAAA,QACAC,cAAA,CACAC,MAAA,SACAC,QAAA,WAaAjC,EAAAI,EAAA,UAEA,IAAAmB,EAAA,CACAW,YAAA,kBACAC,OAAA,4DACAC,OAAA,0DACAC,QAAA,oBAEAZ,EAAA,CACAa,SAAA,CAAaxC,OAAAH,EAAA,EAAAG,CAAC,KAAOA,OAAAH,EAAA,EAAAG,CAAI,WAAaA,OAAAH,EAAA,EAAAG,CAAIA,OAAAH,EAAA,EAAAG,CAAC,OAASA,OAAAH,EAAA,EAAAG,CAAC,MACrDyC,SAAA,CAAAC,EAAA,YAAmC1C,OAAAH,EAAA,EAAAG,CAAC,cACpC2C,MAAA,SAAAZ,GACA,OAAAA,EAAAa,MACA,aACA,oBAEA,aACA,oBAEA,kBACA,OAAAb,EAAA3B,OACA,QACA,kBAEA,QACA,oBAGA,YAEA,cACA,OAAA2B,EAAA3B,OACA,WACA,YACA,qBAEA,WACA,kBAGA,cAGAyC,YAAA,CAAgB7C,OAAAH,EAAA,EAAAG,CAAC,oBACjB8C,YAAA,CAAgB9C,OAAAH,EAAA,EAAAG,CAAC,oBACjB+C,aAAA,CAAiB/C,OAAAH,EAAA,EAAAG,CAAC,sBAClBgD,UAAA,CAAchD,OAAAH,EAAA,EAAAG,CAAC,sBACfiD,UAAA,CAAcjD,OAAAH,EAAA,EAAAG,CAAC,KAAOA,OAAAH,EAAA,EAAAG,CAAI,QAAUA,OAAAH,EAAA,EAAAG,CAAIA,OAAAH,EAAA,EAAAG,CAAC,OAASA,OAAAH,EAAA,EAAAG,CAAC,MACnDkD,YAAA,CAAgBlD,OAAAH,EAAA,EAAAG,CAAC,KAAOA,OAAAH,EAAA,EAAAG,CAAI,cAAgBA,OAAAH,EAAA,EAAAG,CAAIA,OAAAH,EAAA,EAAAG,CAAC,OAASA,OAAAH,EAAA,EAAAG,CAAC,MAC3DmD,YAAA,CAAAT,EAAA,aAAuC1C,OAAAH,EAAA,EAAAG,CAAC,eAGxC,SAAA0C,EAAAU,GACA,OACAA,QACAC,MAAA,SAAAtB,GACA,iBAAAA,EAAAa,MAEAU,OAAA,SAAA/C,EAAAwB,GACAxB,EAAAgD,KAAAxB,EAAA3B,MAAAoD,MAAA,QAKAtD,EAAAwC,EAAA,8CChHAjD,EAAAgE,EAAA9D,EAAA,sBAAA+D,IAAA,IAAAC,EAAAlE,EAAA,IAAAmE,EAAAnE,EAAA,GAAAM,EAAAC,OAAAC,eAEAC,EAAA,SAAAC,EAAAC,GACA,OAAAL,EAAAI,EAAA,QACAC,QACAC,cAAA,KAOA,SAAAqD,IACA,IAAAG,EAAAC,UAAAlD,OAAA,QAAAmD,IAAAD,UAAA,GAAAA,UAAA,IACAzC,cAAA,SAAAC,GACA,OAAAA,EAAA0C,SAA6BL,EAAA,IAE7BnC,SAAcmC,EAAA,EACdjC,WAAgBiC,EAAA,EAChB/B,aAAA,IAEA,OACAE,WAAA,WACA,IAAAmC,EAAA,CACAC,MAAA,EACAC,KAAA,EACAZ,KAAA,KACAX,KAAA,KACAwB,KAAA,KACAC,KAAA,KACAC,gBAAA,EACAC,UAAA,MAGA,OADAC,EAAAX,EAAAnC,WAAAuC,EAAiDL,EAAA,EAAIa,UACrDR,GAEAlC,MAAA,SAAAT,EAAAf,GACA,OAAAmE,EAAApD,EAAAf,EAAAsD,KAOA,SAAAa,EAAApD,EAAAf,EAAAsD,GACA,IAAApD,EAEA,GAAAF,EAAAoE,cACA,OAAArD,EAAA+B,MAAA,UACA9C,EAAAoE,eAAA,EACA,WAEArD,EAAAsD,YACA,UAIA,IAAApD,EAAAqC,EAAArC,SACAE,EAAAmC,EAAAnC,WACAL,EAAAwC,EAAAxC,cACAO,EAAAiC,EAAAjC,aASA,GAPArB,EAAA8D,MAAA,IAAA9D,EAAA8D,KAAAzD,OACAiE,EAAAtE,GACGA,EAAAuE,eACHvE,EAAAuE,cAAA,EACAC,EAAAxE,GAAA,IAGAe,EAAA0D,MAAA,CACA,IAAAnD,GAAA,OAAAD,QAAA,IAAAA,OAAA,EAAAA,EAAAC,UAAA,EACAtB,EAAAS,YAAAiE,KAAAC,MAAA5D,EAAA6D,cAAAtD,GAGA,GAAAR,EAAAC,GACA,WAGA,IAAAS,EAAAqD,EAAA5D,EAAAF,GAEA,IAAAS,EAQA,OAPAT,EAAA+B,MAAA,QAGA/B,EAAA+B,MAAA,MAGAmB,EAAAa,EAAA9E,EAAA,WACA,cAGA,eAAAwB,EAAAa,KAEA,OADA4B,EAAAa,EAAA9E,EAAA,WACA,UAGA,IAAA+E,EAAAC,EAAA,GAA6BhF,GAE7B,mBAAAwB,EAAAa,KACA,YAAY7B,KAAAgB,EAAA3B,YACZ,IAAAG,EAAAS,cACAT,EAAAI,QAAAJ,EAAAI,QAAA,IAAA6E,OAAAjF,EAAAS,YAAA,SAEK,aAAcD,KAAAgB,EAAA3B,OAAA,CACnB,IAAAO,EAAAJ,EAAAI,QAAAJ,EAAAI,QAAA,IAAA6C,MAAA,MAEAjD,EAAAS,aACAL,EAAAC,OAAA,GAAAD,IAAAC,OAAA,GAAAL,EAAAS,cACAT,EAAAS,YAAAL,IAAAC,OAAA,IAMA,KAAAL,EAAA8D,MAAA,CACA,IAAAoB,EAAA,oBAAAlF,EAAA8D,KAAA,IAAA9D,EAAA4D,KAAA5D,EAAA8D,KAAAtC,EAAAT,GAAA,KAAAf,EAAA8D,KAAA9D,EAAA4D,MAMA,GAJA5D,EAAA+D,iBACAmB,EAAA,OAAAA,QAAA,IAAAA,OAAA,EAAAA,EAAAC,WAGAD,EAAA,CAKA,GAJAA,EAAAE,SACAF,IAAAE,QAGA,kBAAAF,EAAA,CACAjB,EAAA9C,EAAAnB,EAAAkF,GACA,SAGA,WAAAhF,EAAAgF,EAAApC,aAAA,IAAA5C,OAAA,EAAAA,EAAAmF,KAAAH,EAAA1D,GAWA,OAVA0D,EAAAnC,QACAmC,EAAAnC,OAAA/C,EAAAwB,GAGA,gBAAAA,EAAAa,KACAmC,EAAAxE,GAAA,GAEAA,EAAAuE,cAAA,EAGAW,EAAArC,MAIAyC,EAAAtF,GAKA,OAFAgF,EAAAhF,EAAA+E,GACAd,EAAAa,EAAA9E,EAAA,WACA,cAKA,SAAAgF,EAAAO,EAAAC,GAGA,IAFA,IAAAC,EAAAhG,OAAAgG,KAAAD,GAEAE,EAAA,EAAiBA,EAAAD,EAAApF,OAAiBqF,IAClCH,EAAAE,EAAAC,IAAAF,EAAAC,EAAAC,IAGA,OAAAH,EAzHA5F,EAAAwD,EAAA,gBAgHAxD,EAAAwE,EAAA,YAYAxE,EAAAqF,EAAA,UAEA,IAAAF,EAAA,CACAa,QAAA,GACAC,QAAA,IAGA,SAAA3B,EAAA4B,EAAA7F,EAAA8F,GACA,IAAAD,EAAAC,GACA,UAAAC,UAAA,iBAAAD,GAGA9F,EAAAgE,UAAAvE,OAAAuF,OAAA,GAAoChF,GACpCA,EAAAqC,KAAAyD,EACA9F,EAAAgD,KAAA,KACAhD,EAAA6D,KAAA,KACA7D,EAAA8D,KAAA+B,EAAAC,GACA9F,EAAA4D,KAAA,EACA5D,EAAA+D,gBAAA,EAKA,SAAAO,EAAAtE,GACAA,EAAAgE,YAIAhE,EAAAqC,KAAArC,EAAAgE,UAAA3B,KACArC,EAAAgD,KAAAhD,EAAAgE,UAAAhB,KACAhD,EAAA6D,KAAA7D,EAAAgE,UAAAH,KACA7D,EAAA8D,KAAA9D,EAAAgE,UAAAF,KACA9D,EAAA4D,KAAA5D,EAAAgE,UAAAJ,KACA5D,EAAA+D,eAAA/D,EAAAgE,UAAAD,eACA/D,EAAAgE,UAAAhE,EAAAgE,qBAKA,SAAAQ,EAAAxE,EAAAgG,GACA,IAAA9F,EAEA,GAAA+F,EAAAjG,MAAA8D,KAAA,CACA,IAAAF,EAAA5D,EAAA8D,KAAA9D,EAAA4D,MAEA,GAAAA,EAAAuB,UAAA,CACA,IAAAA,EAAAvB,EAAAuB,UAGA,GAFAnF,EAAA+D,gBAAA/D,EAAA+D,gBAEA/D,EAAA+D,gBAAAoB,EAAAC,OACA,OAIA,GAAAY,EACA,OAOA,IAHAhG,EAAA+D,gBAAA,EACA/D,EAAA4D,OAEA5D,EAAA8D,QAAAoC,MAAAC,QAAAnG,EAAA8D,OAAA9D,EAAA4D,KAAA5D,EAAA8D,KAAAzD,SACAiE,EAAAtE,GAEAA,EAAA8D,OACAmC,EAAAjG,IACA,QAAAE,EAAAF,EAAA8D,YAAA,IAAA5D,OAAA,EAAAA,EAAAF,EAAA4D,MAAAuB,aACAnF,EAAA+D,gBAAA/D,EAAA+D,iBAGA/D,EAAA+D,gBAAA,EACA/D,EAAA4D,SAQA,SAAAqC,EAAAjG,GACA,IAAA4D,EAAAsC,MAAAC,QAAAnG,EAAA8D,OAAA,kBAAA9D,EAAA8D,KAAA9D,EAAA4D,OAAA5D,EAAA8D,KAAA9D,EAAA4D,MACA,OAAAA,KAAAqC,OAKA,SAAAX,EAAAtF,GACA,KAAAA,EAAA8D,QAAAoC,MAAAC,QAAAnG,EAAA8D,QAAA9D,EAAA8D,KAAA9D,EAAA4D,MAAAwB,SACAd,EAAAtE,GAGAA,EAAA8D,MACAU,EAAAxE,GAAA,GAMA,SAAA6E,EAAA5D,EAAAF,GAGA,IAFA,IAAAqF,EAAA3G,OAAAgG,KAAAxE,GAEAyE,EAAA,EAAiBA,EAAAU,EAAA/F,OAAkBqF,IAAA,CACnC,IAAA5C,EAAA/B,EAAA+B,MAAA7B,EAAAmF,EAAAV,KAEA,GAAA5C,gBAAAoD,MACA,OACA7D,KAAA+D,EAAAV,GACA7F,MAAAiD,EAAA,KAvFAnD,EAAAsE,EAAA,YAgBAtE,EAAA2E,EAAA,WAyCA3E,EAAA6E,EAAA,eAOA7E,EAAAsG,EAAA,UAYAtG,EAAA2F,EAAA,gBAiBA3F,EAAAkF,EAAA","file":"static/js/20.3b18185a.chunk.js","sourcesContent":["var __defProp = Object.defineProperty;\n\nvar __name = function __name(target, value) {\n  return __defProp(target, \"name\", {\n    value: value,\n    configurable: true\n  });\n};\n\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"graphql\";\nimport { p, l as list, o as opt, t } from \"./index.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport \"react\";\nimport \"react-dom\";\nCodeMirror.defineMode(\"graphql-variables\", function (config) {\n  var parser = onlineParser({\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatSpace();\n    },\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {\n      tabSize: config.tabSize\n    }\n  });\n  return {\n    config: config,\n    startState: parser.startState,\n    token: parser.token,\n    indent: indent,\n    electricInput: /^\\s*[}\\]]/,\n    fold: \"brace\",\n    closeBrackets: {\n      pairs: '[]{}\"\"',\n      explode: \"[]{}\"\n    }\n  };\n});\n\nfunction indent(state, textAfter) {\n  var _a, _b;\n\n  var levels = state.levels;\n  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a = this.electricInput) === null || _a === void 0 ? void 0 : _a.test(textAfter)) ? 1 : 0);\n  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);\n}\n\n__name(indent, \"indent\");\n\nvar LexRules = {\n  Punctuation: /^\\[|]|\\{|\\}|:|,/,\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n  String: /^\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?/,\n  Keyword: /^true|false|null/\n};\nvar ParseRules = {\n  Document: [p(\"{\"), list(\"Variable\", opt(p(\",\"))), p(\"}\")],\n  Variable: [namedKey(\"variable\"), p(\":\"), \"Value\"],\n  Value: function Value(token) {\n    switch (token.kind) {\n      case \"Number\":\n        return \"NumberValue\";\n\n      case \"String\":\n        return \"StringValue\";\n\n      case \"Punctuation\":\n        switch (token.value) {\n          case \"[\":\n            return \"ListValue\";\n\n          case \"{\":\n            return \"ObjectValue\";\n        }\n\n        return null;\n\n      case \"Keyword\":\n        switch (token.value) {\n          case \"true\":\n          case \"false\":\n            return \"BooleanValue\";\n\n          case \"null\":\n            return \"NullValue\";\n        }\n\n        return null;\n    }\n  },\n  NumberValue: [t(\"Number\", \"number\")],\n  StringValue: [t(\"String\", \"string\")],\n  BooleanValue: [t(\"Keyword\", \"builtin\")],\n  NullValue: [t(\"Keyword\", \"keyword\")],\n  ListValue: [p(\"[\"), list(\"Value\", opt(p(\",\"))), p(\"]\")],\n  ObjectValue: [p(\"{\"), list(\"ObjectField\", opt(p(\",\"))), p(\"}\")],\n  ObjectField: [namedKey(\"attribute\"), p(\":\"), \"Value\"]\n};\n\nfunction namedKey(style) {\n  return {\n    style: style,\n    match: function match(token) {\n      return token.kind === \"String\";\n    },\n    update: function update(state, token) {\n      state.name = token.value.slice(1, -1);\n    }\n  };\n}\n\n__name(namedKey, \"namedKey\");","var __defProp = Object.defineProperty;\n\nvar __name = function __name(target, value) {\n  return __defProp(target, \"name\", {\n    value: value,\n    configurable: true\n  });\n};\n\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\n\nfunction onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(isIgnored);\n    },\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {}\n  };\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeparator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\n__name(onlineParser, \"onlineParser\");\n\nfunction getToken(stream, state, options) {\n  var _a;\n\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig;\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n\n  if (stream.sol()) {\n    var tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n\n  var token = lex(lexRules, stream);\n\n  if (!token) {\n    var matchedSomething = stream.match(/\\S+/);\n\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n\n  var backupState = assign({}, state);\n\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    var expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n\n    if (state.needsSeparator) {\n      expected = expected === null || expected === void 0 ? void 0 : expected.separator;\n    }\n\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n\n      if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n\n    unsuccessful(state);\n  }\n\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n\n__name(getToken, \"getToken\");\n\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n\n  return to;\n}\n\n__name(assign, \"assign\");\n\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\n\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeparator = false;\n}\n\n__name(pushRule, \"pushRule\");\n\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeparator = state.prevState.needsSeparator;\n  state.prevState = state.prevState.prevState;\n}\n\n__name(popRule, \"popRule\");\n\nfunction advanceRule(state, successful) {\n  var _a;\n\n  if (isList(state) && state.rule) {\n    var step = state.rule[state.step];\n\n    if (step.separator) {\n      var separator = step.separator;\n      state.needsSeparator = !state.needsSeparator;\n\n      if (!state.needsSeparator && separator.ofRule) {\n        return;\n      }\n    }\n\n    if (successful) {\n      return;\n    }\n  }\n\n  state.needsSeparator = false;\n  state.step++;\n\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      if (isList(state)) {\n        if ((_a = state.rule) === null || _a === void 0 ? void 0 : _a[state.step].separator) {\n          state.needsSeparator = !state.needsSeparator;\n        }\n      } else {\n        state.needsSeparator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\n__name(advanceRule, \"advanceRule\");\n\nfunction isList(state) {\n  var step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n\n__name(isList, \"isList\");\n\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n\n__name(unsuccessful, \"unsuccessful\");\n\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n\n    if (match && match instanceof Array) {\n      return {\n        kind: kinds[i],\n        value: match[0]\n      };\n    }\n  }\n}\n\n__name(lex, \"lex\");\n\nexport { onlineParser as o };"],"sourceRoot":""}