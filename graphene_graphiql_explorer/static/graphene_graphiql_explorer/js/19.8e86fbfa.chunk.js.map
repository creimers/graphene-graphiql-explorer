{"version":3,"sources":["../node_modules/@graphiql/react/dist/mode.es2.js","../node_modules/@graphiql/react/dist/onlineParser.es.js"],"names":["__webpack_require__","r","__webpack_exports__","_codemirror_es_js__WEBPACK_IMPORTED_MODULE_0__","_index_es_js__WEBPACK_IMPORTED_MODULE_1__","_onlineParser_es_js__WEBPACK_IMPORTED_MODULE_2__","__defProp","Object","defineProperty","indent","state","textAfter","_a","_b","levels","length","this","electricInput","test","indentLevel","config","indentUnit","defineMode","parser","eatWhitespace","stream","eatSpace","lexRules","LexRules","parseRules","ParseRules","editorConfig","tabSize","startState","token","fold","closeBrackets","pairs","explode","value","configurable","Punctuation","Number","String","Keyword","Document","Entry","Value","kind","NumberValue","StringValue","BooleanValue","NullValue","ListValue","ObjectValue","ObjectField","d","onlineParser","_index_es_js__WEBPACK_IMPORTED_MODULE_0__","graphql__WEBPACK_IMPORTED_MODULE_1__","__name","target","options","arguments","undefined","eatWhile","initialState","level","step","name","type","rule","needsSeparator","prevState","pushRule","DOCUMENT","getToken","inBlockstring","match","skipToEnd","popRule","needsAdvance","advanceRule","sol","Math","floor","indentation","lex","SpecialParseRules","backupState","assign","concat","slice","expected","separator","ofRule","call","update","style","unsuccessful","to","from","keys","i","Invalid","Comment","rules","ruleKind","TypeError","successful","isList","Array","isArray","kinds"],"mappings":"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","file":"static/js/19.8e86fbfa.chunk.js","sourcesContent":["var __defProp = Object.defineProperty;\n\nvar __name = function __name(target, value) {\n  return __defProp(target, \"name\", {\n    value: value,\n    configurable: true\n  });\n};\n\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"graphql\";\nimport { p, l as list, t } from \"./index.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport \"react\";\nimport \"react-dom\";\nCodeMirror.defineMode(\"graphql-results\", function (config) {\n  var parser = onlineParser({\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatSpace();\n    },\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {\n      tabSize: config.tabSize\n    }\n  });\n  return {\n    config: config,\n    startState: parser.startState,\n    token: parser.token,\n    indent: indent,\n    electricInput: /^\\s*[}\\]]/,\n    fold: \"brace\",\n    closeBrackets: {\n      pairs: '[]{}\"\"',\n      explode: \"[]{}\"\n    }\n  };\n});\n\nfunction indent(state, textAfter) {\n  var _a, _b;\n\n  var levels = state.levels;\n  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a = this.electricInput) === null || _a === void 0 ? void 0 : _a.test(textAfter)) ? 1 : 0);\n  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);\n}\n\n__name(indent, \"indent\");\n\nvar LexRules = {\n  Punctuation: /^\\[|]|\\{|\\}|:|,/,\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n  String: /^\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?/,\n  Keyword: /^true|false|null/\n};\nvar ParseRules = {\n  Document: [p(\"{\"), list(\"Entry\", p(\",\")), p(\"}\")],\n  Entry: [t(\"String\", \"def\"), p(\":\"), \"Value\"],\n  Value: function Value(token) {\n    switch (token.kind) {\n      case \"Number\":\n        return \"NumberValue\";\n\n      case \"String\":\n        return \"StringValue\";\n\n      case \"Punctuation\":\n        switch (token.value) {\n          case \"[\":\n            return \"ListValue\";\n\n          case \"{\":\n            return \"ObjectValue\";\n        }\n\n        return null;\n\n      case \"Keyword\":\n        switch (token.value) {\n          case \"true\":\n          case \"false\":\n            return \"BooleanValue\";\n\n          case \"null\":\n            return \"NullValue\";\n        }\n\n        return null;\n    }\n  },\n  NumberValue: [t(\"Number\", \"number\")],\n  StringValue: [t(\"String\", \"string\")],\n  BooleanValue: [t(\"Keyword\", \"builtin\")],\n  NullValue: [t(\"Keyword\", \"keyword\")],\n  ListValue: [p(\"[\"), list(\"Value\", p(\",\")), p(\"]\")],\n  ObjectValue: [p(\"{\"), list(\"ObjectField\", p(\",\")), p(\"}\")],\n  ObjectField: [t(\"String\", \"property\"), p(\":\"), \"Value\"]\n};","var __defProp = Object.defineProperty;\n\nvar __name = function __name(target, value) {\n  return __defProp(target, \"name\", {\n    value: value,\n    configurable: true\n  });\n};\n\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\n\nfunction onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(isIgnored);\n    },\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {}\n  };\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeparator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\n__name(onlineParser, \"onlineParser\");\n\nfunction getToken(stream, state, options) {\n  var _a;\n\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig;\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n\n  if (stream.sol()) {\n    var tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n\n  var token = lex(lexRules, stream);\n\n  if (!token) {\n    var matchedSomething = stream.match(/\\S+/);\n\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n\n  var backupState = assign({}, state);\n\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    var expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n\n    if (state.needsSeparator) {\n      expected = expected === null || expected === void 0 ? void 0 : expected.separator;\n    }\n\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n\n      if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n\n    unsuccessful(state);\n  }\n\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n\n__name(getToken, \"getToken\");\n\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n\n  return to;\n}\n\n__name(assign, \"assign\");\n\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\n\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeparator = false;\n}\n\n__name(pushRule, \"pushRule\");\n\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeparator = state.prevState.needsSeparator;\n  state.prevState = state.prevState.prevState;\n}\n\n__name(popRule, \"popRule\");\n\nfunction advanceRule(state, successful) {\n  var _a;\n\n  if (isList(state) && state.rule) {\n    var step = state.rule[state.step];\n\n    if (step.separator) {\n      var separator = step.separator;\n      state.needsSeparator = !state.needsSeparator;\n\n      if (!state.needsSeparator && separator.ofRule) {\n        return;\n      }\n    }\n\n    if (successful) {\n      return;\n    }\n  }\n\n  state.needsSeparator = false;\n  state.step++;\n\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      if (isList(state)) {\n        if ((_a = state.rule) === null || _a === void 0 ? void 0 : _a[state.step].separator) {\n          state.needsSeparator = !state.needsSeparator;\n        }\n      } else {\n        state.needsSeparator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\n__name(advanceRule, \"advanceRule\");\n\nfunction isList(state) {\n  var step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n\n__name(isList, \"isList\");\n\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n\n__name(unsuccessful, \"unsuccessful\");\n\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n\n    if (match && match instanceof Array) {\n      return {\n        kind: kinds[i],\n        value: match[0]\n      };\n    }\n  }\n}\n\n__name(lex, \"lex\");\n\nexport { onlineParser as o };"],"sourceRoot":""}